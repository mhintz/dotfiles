" Things to do:
" set up Ctrl-P to have more file listing command options, or possibly setup the "Command-T" plugin
" set up YouCompleteMe
" set up fzf

execute pathogen#infect()
" to generate documentation for all pathogen-installed plugins, run :Helptags

" this might be unnecessary, but it's nice to be clear
set nocompatible

" encoding
set encoding=utf-8

" turn on filetype, plugin, and indent
filetype plugin indent on

" ***** THEME AND HIGHLIGHTING ******

" syntax highlighting
syntax on

" this print formatting chars are required for vim-one
set t_8b=[48;2;%lu;%lu;%lum
set t_8f=[38;2;%lu;%lu;%lum
" get those nice colors
set termguicolors
" italics
let g:one_allow_italics = 1
" sets the dark theme
set background=dark
" set the color scheme
" colorscheme one
colorscheme OceanicNext
" colorscheme seoul256
" colorscheme neuromancer
" colorscheme vice
" set vim-airline theme to also use the 'vim-one' styles
let g:airline_theme='one'

" ****** SETTINGS ******

" reloads when a file is changed in the background
set autoread

" incremental search
set incsearch
" highlighted search
set hlsearch
set nohlsearch

" expected backspace behavior (backspace can delete over indent, eol, and the
" start of your editing)
set backspace=indent,eol,start
" and arrow key movement wraps around line breaks
set whichwrap+=<,>

" history settings
set history=50

" vim "UI" settings
set ruler
set showcmd
set number

set backup
" set vim directories for undo, backup, and swap files
set undodir=$HOME/.vim/.undo//
set backupdir=$HOME/.vim/.backup//
set directory^=$HOME/.vim/.swp//

" try to keep the cursor at least 3 lines from the edge of the window
set scrolloff=3

" allow files to be open as buffers without being visible
set hidden

" no line wrap
" set nowrap
set wrap
set breakindent
set breakindentopt=sbr
" Unicode curly arrow, space
set showbreak=â†ª

" indentation settings
set autoindent
set smartindent
set tabstop=4
set shiftwidth=4
set expandtab
set softtabstop=4

" ****** SET LEADER KEY ******
let mapleader = " "

" ****** PLUGIN SETTINGS ******

" ctrlp settings
let g:ctrlp_show_hidden = 1
let g:ctrlp_working_path_mode = 'a'
let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files -co --exclude-standard']
let g:ctrlp_extensions = ['dir']

" NERDTree Settings
nnoremap <leader>o :NERDTreeToggle<CR>
let g:NERDTreeWinSize=20
let g:NERDTreeShowHidden=1
" open a NERDTree automatically (and move to the main window) when vim is opened or a new tab is made
" autocmd vimenter * NERDTree | wincmd l
" autocmd tabnew * NERDTree | wincmd l
" close the nerd tree window if it's the last one open
" autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif

" multi-cursor settings
let g:multi_cursor_next_key='<C-g>'

" vim-airline disable tmuxline integration (it doesn't render correctly)
let g:airline#extensions#tmuxline#enabled = 0
let g:airline#extensions#tabline#enabled = 1

" Tmuxline (styles get overriden incorrectly, need to refresh it on enter"
let g:tmuxline_powerline_separators = 0

" ack package settings (for using ag instead)
if executable('ag')
    let g:ackprg = 'ag --vimgrep --hidden'
endif
cnoreabbrev ag Ack
cnoreabbrev aG Ack
cnoreabbrev Ag Ack
cnoreabbrev AG Ack

" autocmd to pulse the cursorline when focus is returned to vim
" copied (like some other commands here) from
" https://github.com/airblade/dotvim/blob/master/vimrc
function! s:Pulse()
    sleep 100m

    setlocal cursorline
    redraw
    sleep 100m

    setlocal nocursorline
    redraw
endfunction
autocmd FocusGained * call s:Pulse()

" ****** KEYBINDINGS ******

" manually reload vim config
nnoremap <leader>r :source ~/.vim/vimrc<CR>
" open help in a side window
nnoremap <leader><C-H> :vert bo help<CR>

" ****** BUFFERS, WINDOWS, AND TABS ******
nnoremap <leader>w :w<CR>
nnoremap <leader>q :q<CR>

nnoremap <leader>a :Ack!<Space>

" move between windows
noremap <leader>j <C-W>j
noremap <leader>k <C-W>k
noremap <leader>l <C-W>l
noremap <leader>h <C-W>h

nnoremap <Tab> <C-w>w
nnoremap <S-Tab> <C-w>W

" Use | and _ to split windows (while preserving original behaviour of
" [count]bar and [count]_).
nnoremap <expr><silent> <Bar> v:count == 0 ? "<C-W>v<C-W><Right>" : ":<C-U>normal! 0".v:count."<Bar><CR>"
nnoremap <expr><silent> -     v:count == 0 ? "<C-W>s<C-W><Down>"  : ":<C-U>normal! ".v:count."-<CR>"

" edit the last-edited file
nnoremap <leader><leader> :e#<CR>

" create buffers / tabs
nnoremap <leader>bn :enew<CR>
nnoremap <leader>bd :bdelete<CR>
nnoremap <leader>bb :b#<CR>

nnoremap <leader>tn :tabnew<CR>
nnoremap <leader>td :tabclose<CR>
nnoremap <leader>tb :tabp<CR>

" move between buffers / tabs
noremap <leader>n :bnext<CR>
noremap <leader>m :bprev<CR>
noremap <leader><Left> :bnext<CR>
noremap <leader><Right> :bprev<CR>
noremap <leader><C-N> :tabn<CR>
noremap <leader><C-M> :tabp<CR>

" map <leader># to switch to buffer #
for i in range(1, 9)
    execute 'nnoremap <leader>'.i.' :buffer '.i.'<CR>'
endfor

" ****** EDITING COMMANDS ******

" clear search highlights if they add visual clutter
noremap <leader>cc :nohlsearch<CR>

" remove trailing whitespace
" autocmd BufWritePre * :%s/\s\+$//e
nnoremap <leader>cw :%s/\s\+$//e<CR>

" Opposite of join (breaK?).
" A space is replaced with a carriage return; otherwise a carriage return is inserted.
nnoremap <expr> K getline('.')[col('.') - 1] == ' ' ? "r<CR>" : "i<CR><ESC>l"

" duplicate line
nnoremap <leader>dd yyp

" faster scrolling
noremap <C-n> 6<C-e>6j
noremap <C-m> 6<C-y>6k

noremap <C-j> 6j
noremap <C-k> 6k

noremap <C-M-n> 6<C-e>
noremap <C-M-m> 6<C-y>

" start / end of line movement like emacs
noremap <C-a> ^
noremap <C-e> $

" these bindings overwrite the ones provided by vim-rsi
inoremap <C-a> <C-o>^
inoremap <C-e> <C-o>$

cnoremap <C-a> <Home>
cnoremap <C-e> <End>

" delete into a specific register (register d)
nnoremap dd "ddd
" cut into specific register (x)
vnoremap <leader>x "xx
" paste from that specific register (x)
nnoremap <leader>p "xgp
" use this to paste from system pasteboard
nnoremap <leader>v :set paste<CR>"*gP:set nopaste<CR>

" delete to end of line
inoremap <C-k> <C-o>d$

" move lines of text around vertically
nnoremap <C-M-j> mz:m+<cr>`z
nnoremap <C-M-k> mz:m-2<cr>`z
vnoremap <C-M-j> :m'>+<cr>`<my`>mzgv`yo`z
vnoremap <C-M-k> :m'<-2<cr>`>my`<mzgv`yo`z

" moving around in insert mode
inoremap <M-j> <C-o>j
inoremap <M-k> <C-o>k
" inoremap <M-b> <C-o>b
inoremap <M-e> <ESC>eli
inoremap <M-w> <C-o>w

" Have terminal set up to send "<leader>dw" on <Ctrl+Del>
nmap <expr> <leader>dw col('.')==strlen(getline('.'))?"dbxa":"dbxi"

" while I learn, some key bindings to make me feel like home :)
" (there's more to these lines than meets the eye)

" this is <M-Right>
" inoremap f <C-o>e
" this is <M-Left> (unfortunately, it is <esc>b so it clashes)
" inoremap b <C-o>b
" this is <M-up>
" inoremap [1;3A <C-o>6k
" this is <M-down>
" inoremap [1;3B <C-o>6j
" this is <M-BS>
" inoremap  <C-w>

" these lines provide some simple context scrolling in insert mode (I know
" it's bad to add weird movement commands in insert mode but I can't help it)
inoremap <M-m> <ESC>6<C-y>6ki
inoremap <M-n> <ESC>6<C-e>6ji
